Comparing outputs/test00.output and samples/test00.sample (ignoring memory addresses, specific strings, and handling code splits):
21,22c21,22
< movl	$1,%xmm0         	#  1 -> %xmm0
< movsd	%xmm0,-32(%rbp)     	#  %xmm0 -> i
---
> movl	$1,%eax         	#  1 -> %eax
> movl	%eax,-32(%rbp)     	#  %eax -> i
Comparing outputs/test01.output and samples/test01.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test02.output and samples/test02.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test03.output and samples/test03.sample (ignoring memory addresses, specific strings, and handling code splits):
22,23c22,23
< movl	$1,%xmm0         	#  1 -> %xmm0
< addsd	%xmm0,%eax         	#  %eax + %xmm0 -> %eax
---
> movl	$1,%ecx         	#  1 -> %ecx
> addl	%ecx,%eax         	#  %eax + %ecx -> %eax
Comparing outputs/test04.output and samples/test04.sample (ignoring memory addresses, specific strings, and handling code splits):
22,23c22,23
< movl	$1,%xmm0         	#  1 -> %xmm0
< subsd	%xmm0,%eax         	#  %eax - %xmm0 -> %eax
---
> movl	$1,%ecx         	#  1 -> %ecx
> subl	%ecx,%eax         	#  %eax - %ecx -> %eax
Comparing outputs/test05.output and samples/test05.sample (ignoring memory addresses, specific strings, and handling code splits):
22,23c22,23
< movl	$2,%xmm0         	#  2 -> %xmm0
< mulsd	%xmm0,%eax         	#  %eax * %xmm0 -> %eax
---
> movl	$2,%ecx         	#  2 -> %ecx
> imull	%ecx,%eax         	#  %eax * %ecx -> %eax
Comparing outputs/test06.output and samples/test06.sample (ignoring memory addresses, specific strings, and handling code splits):
22,23c22,23
< movl	$2,%xmm0         	#  2 -> %xmm0
< divsd	%xmm0,%eax         	#  %eax / %xmm0 -> %eax
---
> movl	$2,%ecx         	#  2 -> %ecx
> divl	%ecx,%eax         	#  %eax / %ecx -> %eax
Comparing outputs/test07.output and samples/test07.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test08.output and samples/test08.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test09.output and samples/test09.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test10.output and samples/test10.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test11.output and samples/test11.sample (ignoring memory addresses, specific strings, and handling code splits):
23c23
< cvtsi2sd	%eax,%xmm1    	#  float %eax -> %xmm1
---
> cvtsi2sd	%eax,%xmm0    	#  float %eax -> %xmm0
Comparing outputs/test12.output and samples/test12.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test13.output and samples/test13.sample (ignoring memory addresses, specific strings, and handling code splits):
25,26c25,26
< movl	$1,%xmm0         	#  1 -> %xmm0
< addsd	%xmm0,%eax         	#  %eax + %xmm0 -> %eax
---
> movl	$1,%ecx         	#  1 -> %ecx
> addl	%ecx,%eax         	#  %eax + %ecx -> %eax
29,30c29,30
< movl	$1,%xmm0         	#  1 -> %xmm0
< addsd	%xmm0,%eax         	#  %eax + %xmm0 -> %eax
---
> movl	$1,%ecx         	#  1 -> %ecx
> addl	%ecx,%eax         	#  %eax + %ecx -> %eax
Comparing outputs/test14.output and samples/test14.sample (ignoring memory addresses, specific strings, and handling code splits):
7c7
< (progn (progn (label 0)
---
> (progn (label 0)
9,10c9,10
< (progn (progn (:= i (+ i 1)))
< (goto 0))))))
---
> (progn (:= i (+ i 1))
> (goto 0)))))
28,29c28,29
< movq	$0,jmp         	#  0 -> jmp
< cmpq	jmp,%rax           	#  compare %rax - jmp
---
> movq	$0,%rcx         	#  0 -> %rcx
> cmpq	%rcx,%rax           	#  compare %rax - %rcx
34,35c34,35
< movl	$1,%xmm0         	#  1 -> %xmm0
< addsd	%xmm0,%eax         	#  %eax + %xmm0 -> %eax
---
> movl	$1,%ecx         	#  1 -> %ecx
> addl	%ecx,%eax         	#  %eax + %ecx -> %eax
Comparing outputs/test15.output and samples/test15.sample (ignoring memory addresses, specific strings, and handling code splits):
6c6
< (progn (progn (:= i 0)
---
> (progn (:= i 0)
11c11
< (goto 0))))))
---
> (goto 0)))))
27,28c27,28
< movl	$0,%xmm0         	#  0 -> %xmm0
< movsd	%xmm0,-32(%rbp)     	#  %xmm0 -> i
---
> movl	$0,%eax         	#  0 -> %eax
> movl	%eax,-32(%rbp)     	#  %eax -> i
31,32c31,32
< movl	$32,%xmm0         	#  32 -> %xmm0
< cmpl	%xmm0,%eax           	#  compare %eax - %xmm0
---
> movl	$32,%ecx         	#  32 -> %ecx
> cmpl	%ecx,%eax           	#  compare %eax - %ecx
36,37c36,37
< movl	$1,%xmm0         	#  1 -> %xmm0
< movsd	%xmm0,-28(%rbp)     	#  %xmm0 -> n
---
> movl	$1,%eax         	#  1 -> %eax
> movl	%eax,-28(%rbp)     	#  %eax -> n
39,40c39,40
< movl	$1,%xmm0         	#  1 -> %xmm0
< addsd	%xmm0,%eax         	#  %eax + %xmm0 -> %eax
---
> movl	$1,%ecx         	#  1 -> %ecx
> addl	%ecx,%eax         	#  %eax + %ecx -> %eax
Comparing outputs/test16.output and samples/test16.sample (ignoring memory addresses, specific strings, and handling code splits):
7c7
< (progn (:= n (- n 1)))
---
> (:= n (- n 1))
26,27c26,27
< movl	$1,%xmm0         	#  1 -> %xmm0
< movsd	%xmm0,-32(%rbp)     	#  %xmm0 -> n
---
> movl	$1,%eax         	#  1 -> %eax
> movl	%eax,-32(%rbp)     	#  %eax -> n
30,31c30,31
< movl	$1,%xmm0         	#  1 -> %xmm0
< subsd	%xmm0,%eax         	#  %eax - %xmm0 -> %eax
---
> movl	$1,%ecx         	#  1 -> %ecx
> subl	%ecx,%eax         	#  %eax - %ecx -> %eax
34,35c34,35
< movl	$0,%xmm0         	#  0 -> %xmm0
< cmpl	%xmm0,%eax           	#  compare %eax - %xmm0
---
> movl	$0,%ecx         	#  0 -> %ecx
> cmpl	%ecx,%eax           	#  compare %eax - %ecx
Comparing outputs/test17.output and samples/test17.sample (ignoring memory addresses, specific strings, and handling code splits):
21,22c21,22
< movl	-32(%rbp),%xmm0     	#  i -> %xmm0
< movl	%xmm0,%edi         	#  %xmm0 -> %edi
---
> movl	-32(%rbp),%eax     	#  i -> %eax
> movl	%eax,%edi         	#  %eax -> %edi
Comparing outputs/test18.output and samples/test18.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test19.output and samples/test19.sample (ignoring memory addresses, specific strings, and handling code splits):
22,23c22,23
< movl	$8,%xmm0         	#  8 -> %xmm0
< movl	%xmm0,%edi         	#  %xmm0 -> %edi
---
> movl	$8,%eax         	#  8 -> %eax
> movl	%eax,%edi         	#  %eax -> %edi
Comparing outputs/test20.output and samples/test20.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test21.output and samples/test21.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,30c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test23.output and samples/test23.sample (ignoring memory addresses, specific strings, and handling code splits):
Comparing outputs/test24.output and samples/test24.sample (ignoring memory addresses, specific strings, and handling code splits):
27,28c27,29
< movl	$96,%xmm0         	#  96 -> %xmm0
< movsd	96(%rax),%xmm0         	#  ^.[96+%rax] -> %xmm0
---
> movl	$96,%eax         	#  96 -> %eax
> cltq	                  	#  sign-extend
> movsd	-192(%rbp,%rax),%xmm0         	#  ac[-192] -> %xmm0
Comparing outputs/test25.output and samples/test25.sample (ignoring memory addresses, specific strings, and handling code splits):
41,43c41,43
< movl	$19,%xmm0         	#  19 -> %xmm0
< movq	-32(%rbp),jne     	#  john -> jne
< movl	%xmm0,0(jne)         	#  %xmm0 -> ^. [0+jne]
---
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
Comparing outputs/test26.output and samples/test26.sample (ignoring memory addresses, specific strings, and handling code splits):
42,43c42,43
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
Comparing outputs/test27.output and samples/test27.sample (ignoring memory addresses, specific strings, and handling code splits):
44,45c44,45
< movq	8(jne),je         	#  ^.[8+jne] -> je
< movsd	%xmm0,24(je)         	#  %xmm0 -> ^. [24+je]
---
> movq	8(%rax),%rcx         	#  ^.[8+%rax] -> %rcx
> movsd	%xmm0,24(%rcx)         	#  %xmm0 -> ^. [24+%rcx]
Comparing outputs/test28.output and samples/test28.sample (ignoring memory addresses, specific strings, and handling code splits):
43,45c43,45
< movq	8(jmp),jne         	#  ^.[8+jmp] -> jne
< movsd	24(jne),%xmm1         	#  ^.[24+jne] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
---
> movq	8(%rax),%rcx         	#  ^.[8+%rax] -> %rcx
> movsd	24(%rcx),%xmm0         	#  ^.[24+%rcx] -> %xmm0
> movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
Comparing outputs/test29.output and samples/test29.sample (ignoring memory addresses, specific strings, and handling code splits):
56,73c56,73
< movl	$19,%xmm0         	#  19 -> %xmm0
< movq	-32(%rbp),jne     	#  john -> jne
< movl	%xmm0,0(jne)         	#  %xmm0 -> ^. [0+jne]
< movl	$19,%xmm0         	#  19 -> %xmm0
< movq	-32(%rbp),jne     	#  john -> jne
< movl	%xmm0,0(jne)         	#  %xmm0 -> ^. [0+jne]
< movl	$19,%xmm0         	#  19 -> %xmm0
< movq	-32(%rbp),jne     	#  john -> jne
< movl	%xmm0,0(jne)         	#  %xmm0 -> ^. [0+jne]
< movl	$19,%xmm0         	#  19 -> %xmm0
< movq	-32(%rbp),jne     	#  john -> jne
< movl	%xmm0,0(jne)         	#  %xmm0 -> ^. [0+jne]
< movl	$19,%xmm0         	#  19 -> %xmm0
< movq	-32(%rbp),jne     	#  john -> jne
< movl	%xmm0,0(jne)         	#  %xmm0 -> ^. [0+jne]
< movl	$19,%xmm0         	#  19 -> %xmm0
< movq	-32(%rbp),jne     	#  john -> jne
< movl	%xmm0,0(jne)         	#  %xmm0 -> ^. [0+jne]
---
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
Comparing outputs/test30.output and samples/test30.sample (ignoring memory addresses, specific strings, and handling code splits):
52,53c52,53
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
55,56c55,56
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
58,59c58,59
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
61,62c61,62
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
64,65c64,65
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
67,68c67,68
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
l	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
> movl	$19,%eax         	#  19 -> %eax
> movq	-32(%rbp),%rcx     	#  john -> %rcx
> movl	%eax,0(%rcx)         	#  %eax -> ^. [0+%rcx]
Comparing outputs/test30.output and samples/test30.sample (ignoring memory addresses, specific strings, and handling code splits):
52,53c52,53
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
55,56c55,56
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
58,59c58,59
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
61,62c61,62
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
64,65c64,65
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
67,68c67,68
< movl	0(jmp),%xmm1         	#  ^.[0+jmp] -> %xmm1
< movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> sum
---
> movl	0(%rax),%ecx         	#  ^.[0+%rax] -> %ecx
> movl	%ecx,-24(%rbp)     	#  %ecx -> sum
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,30c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,30c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,30c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,52d22
< In genc()
< (progn (:= y (* (funcall exp x)
< (funcall sin x))))
< PROGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))
< In genc()
< (:= y (* (funcall exp x)
< (funcall sin x)))
< ASSIGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))#####
< y
< In genarith()
< (* (funcall exp x)
< (funcall sin x))
< In genarith()
< (funcall exp x)
< In genarith()
< exp
< IDENTIFIERTOK detected; symbol table entry:
< exp          exp knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
54,55d23
< OPERATOR detected, from genarith().
< 24 16 17
57,71c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< In genarith()
< (funcall sin x)
< In genarith()
< sin
< IDENTIFIERTOK detected; symbol table entry:
< sin          sin knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
73,74d26
< OPERATOR detected, from genarith().
< 24 16 17
76,80c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< OPERATOR detected, from genarith().
< 3 0 16
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,52d22
< In genc()
< (progn (:= y (* (funcall exp x)
< (funcall sin x))))
< PROGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))
< In genc()
< (:= y (* (funcall exp x)
< (funcall sin x)))
< ASSIGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))#####
< y
< In genarith()
< (* (funcall exp x)
< (funcall sin x))
< In genarith()
< (funcall exp x)
< In genarith()
< exp
< IDENTIFIERTOK detected; symbol table entry:
< exp          exp knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
54,55d23
< OPERATOR detected, from genarith().
< 24 16 17
57,71c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< In genarith()
< (funcall sin x)
< In genarith()
< sin
< IDENTIFIERTOK detected; symbol table entry:
< sin          sin knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
73,74d26
< OPERATOR detected, from genarith().
< 24 16 17
76,80c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< OPERATOR detected, from genarith().
< 3 0 16
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,53d22
< In genc()
< (progn (:= y (* (funcall exp x)
< (funcall sin x))))
< PROGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))
< In genc()
< (:= y (* (funcall exp x)
< (funcall sin x)))
< ASSIGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))#####
< y
< In genarith()
< (* (funcall exp x)
< (funcall sin x))
< In genarith()
< (funcall exp x)
< In genarith()
< exp
< IDENTIFIERTOK detected; symbol table entry:
< exp          exp knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
< was it here
55,56d23
< OPERATOR detected, from genarith().
< 24 16 17
58,73c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< In genarith()
< (funcall sin x)
< In genarith()
< sin
< IDENTIFIERTOK detected; symbol table entry:
< sin          sin knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
< was it here
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
75,76d26
< OPERATOR detected, from genarith().
< 24 16 17
78,82c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< OPERATOR detected, from genarith().
< 3 0 16
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,52d22
< In genc()
< (progn (:= y (* (funcall exp x)
< (funcall sin x))))
< PROGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))
< In genc()
< (:= y (* (funcall exp x)
< (funcall sin x)))
< ASSIGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))#####
< y
< In genarith()
< (* (funcall exp x)
< (funcall sin x))
< In genarith()
< (funcall exp x)
< In genarith()
< exp
< IDENTIFIERTOK detected; symbol table entry:
< exp          exp knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
54,55d23
< OPERATOR detected, from genop().
< 24 16 17
57,71c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< In genarith()
< (funcall sin x)
< In genarith()
< sin
< IDENTIFIERTOK detected; symbol table entry:
< sin          sin knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
73,74d26
< OPERATOR detected, from genop().
< 24 16 17
76,80c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< OPERATOR detected, from genop().
< 3 0 16
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,52d22
< In genc()
< (progn (:= y (* (funcall exp x)
< (funcall sin x))))
< PROGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))
< In genc()
< (:= y (* (funcall exp x)
< (funcall sin x)))
< ASSIGNOP detected.
< (:= y (* (funcall exp x)
< (funcall sin x)))#####
< y
< In genarith()
< (* (funcall exp x)
< (funcall sin x))
< In genarith()
< (funcall exp x)
< In genarith()
< exp
< IDENTIFIERTOK detected; symbol table entry:
< exp          exp knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
54,55d23
< OPERATOR detected, from genop().
< 24 16 17
57,71c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< In genarith()
< (funcall sin x)
< In genarith()
< sin
< IDENTIFIERTOK detected; symbol table entry:
< sin          sin knd 5 0  typ  lvl 0  siz     0  off     0 lnk
< offset: 0
< In genc()
< x
< In genarith()
< x
< IDENTIFIERTOK detected; symbol table entry:
< x            x knd 3 1  typ  lvl 1  siz     8  off     0 lnk
< offset: 0
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
73,74d26
< OPERATOR detected, from genop().
< 24 16 17
76,79c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< OPERATOR detected, from genop().
< 3 0 16
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,29c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28c28,29
< movsd	-8(%rbp),%eax     	#  temp -> %eax
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28c28,29
< movsd	-8(%rbp),%eax     	#  temp -> %eax
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,29c28,29
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< MIXED MODE MULTIPLICATION
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,31c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
25c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
28,32c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
30,33c25
< movsd	(null),-8(%rbp)     	#  (null) -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36,40c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
30,33c25
< movsd	(null),-8(%rbp)     	#  (null) -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36,40c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
30,34c25
< saved_inline_reg: 0
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
37,41c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
31,34c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36d26
< saved_inline_reg: 0
38,42c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
32,34d25
< code:   (funcall sin x)
< code:   sin
< code:   x
36d26
< saved_inline_reg: 0
38c28
< movsd	-8(%rbp),%eax     	#  temp -> %eax
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
40c30
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
32,34d25
< code:   (funcall sin x)
< code:   sin
< code:   x
36d26
< saved_inline_reg: 0
38c28
< movsd	-8(%rbp),%eax     	#  temp -> %eax
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
40c30
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
32,35d25
< IF saved: 16
< code:   (funcall sin x)
< code:   sin
< code:   x
37d26
< saved_inline_reg: 16
39,40c28
< movsd	-8(%rbp),%xmm0     	#  temp -> %xmm0
< IF saved: 16
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
42,43c30
< IF saved: 16
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
31,35c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< IF saved: 16
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
37d26
< saved_inline_reg: 16
39,45c28,30
< movsd	-8(%rbp),%xmm0     	#  temp -> %xmm0
< IF saved: 16
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< IF saved: 0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
31,34c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36d26
< saved_inline_reg: 0
38,42c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
31,34c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36d26
< saved_inline_reg: 0
38,42c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
31,34c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36d26
< saved_inline_reg: 0
38,42c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 0
31,34c25
< movsd	%eax,-8(%rbp)     	#  %eax -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36d26
< saved_inline_reg: 0
38,42c28,30
< movsd	-8(%rbp),%eax     	#  temp -> %eax
< rhs_reg: 0
< mulsd	%eax,%xmm0         	#  %xmm0 * %eax -> %xmm0
< MIXED MODE MULTIPLICATION
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,27d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
29d23
< saved_inline_reg: 18
31,34c25
< movsd	%xmm2,-8(%rbp)     	#  %xmm2 -> temp
< code:   (funcall sin x)
< code:   sin
< code:   x
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
36d26
< saved_inline_reg: 17
39c29
< mulsd	%xmm2,%xmm1         	#  %xmm1 * %xmm2 -> %xmm1
---
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,29d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< i: 16
< code:   x
< i: 16
31,36d23
< i: 16
< i: 17
< i: 16
< i: 17
< i: 18
< saved_inline_reg: 18
38,45c25
< movsd	%xmm2,-8(%rbp)     	#  %xmm2 -> temp
< i: 16
< code:   (funcall sin x)
< code:   sin
< i: 16
< i: 17
< code:   x
< i: 16
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
47,49d26
< i: 16
< i: 17
< saved_inline_reg: 17
52c29
< mulsd	%xmm2,%xmm1         	#  %xmm1 * %xmm2 -> %xmm1
---
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,29d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< i: 16
< code:   x
< i: 16
31,34d23
< i: 16
< i: 16
< i: 17
< saved_inline_reg: 17
36,43c25
< movsd	%xmm1,-8(%rbp)     	#  %xmm1 -> temp
< i: 16
< code:   (funcall sin x)
< code:   sin
< i: 16
< i: 17
< code:   x
< i: 16
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
45,46d26
< i: 16
< saved_inline_reg: 16
48,50c28,30
< movsd	-8(%rbp),%xmm0     	#  temp -> %xmm0
< mulsd	%xmm1,%xmm0         	#  %xmm0 * %xmm1 -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,29d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< i: 16
< code:   x
< i: 16
31,34d23
< i: 16
< i: 16
< i: 17
< saved_inline_reg: 17
36,43c25
< movsd	%xmm1,-8(%rbp)     	#  %xmm1 -> temp
< i: 16
< code:   (funcall sin x)
< code:   sin
< i: 16
< i: 17
< code:   x
< i: 16
---
> movsd	%xmm0,-8(%rbp)     	#  %xmm0 -> temp
45,46d26
< i: 16
< saved_inline_reg: 16
48,50c28,30
< movsd	-8(%rbp),%xmm0     	#  temp -> %xmm0
< mulsd	%xmm1,%xmm0         	#  %xmm0 * %xmm1 -> %xmm0
< movsd	%xmm0,-24(%rbp)     	#  %xmm0 -> y
---
> movsd	-8(%rbp),%xmm1     	#  temp -> %xmm1
> mulsd	%xmm0,%xmm1         	#  %xmm1 * %xmm0 -> %xmm1
> movsd	%xmm1,-24(%rbp)     	#  %xmm1 -> y
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,28d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
< i: 16
30,31d23
< i: 16
< saved_inline_reg: 16
34,37d25
< code:   (funcall sin x)
< code:   sin
< code:   x
< i: 16
39,42d26
< i: 16
< i: 16
< i: 17
< saved_inline_reg: 17
45,46d28
< i: 16
< Error: cannot free register number 32767
Comparing outputs/test22.output and samples/test22.sample (ignoring memory addresses, specific strings, and handling code splits):
23,28d22
< code:   (* (funcall exp x)
< (funcall sin x))
< code:   (funcall exp x)
< code:   exp
< code:   x
< i: 16
30,31d23
< i: 16
< saved_inline_reg: 16
34,37d25
< code:   (funcall sin x)
< code:   sin
< code:   x
< i: 16
39,42d26
< i: 16
< i: 16
< i: 17
< saved_inline_reg: 17
45d28
< i: 16
